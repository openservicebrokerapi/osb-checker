package store

import (
	"encoding/json"
	"errors"
	"reflect"

	openapi "github.com/openservicebrokerapi/osb-checker/autogenerated/models"
)

var catalogPayload openapi.Catalog
var serviceInstancePayloadList []*ServiceInstancePayload
var serviceBindingPayloadList []*ServiceBindingPayload

func init() {
	if err := json.Unmarshal([]byte(CatalogJSONPayload), &catalogPayload); err != nil {
		panic(err)
	}
}

type ServiceInstancePayload struct {
	InstanceID string
	Payload    *openapi.ServiceInstanceResource
}

type ServiceBindingPayload struct {
	ServiceID, PlanID     string
	InstanceID, BindingID string
	Payload               *openapi.ServiceBindingResource
}

func GetCatalogPayload() *openapi.Catalog {
	return &catalogPayload
}

func StoreServiceInstancePayload(payload *ServiceInstancePayload) {
	serviceInstancePayloadList = append(serviceInstancePayloadList, payload)
}

func FindServiceInstancePayload(instanceID string) (*ServiceInstancePayload, error) {
	for _, v := range serviceInstancePayloadList {
		if instanceID == v.InstanceID {
			return v, nil
		}
	}
	return nil, errors.New("cannot find specified service instance!")
}

func RefreshServiceInstancePayload(instanceID, planID string, params map[string]interface{}) {
	for k, v := range serviceInstancePayloadList {
		if instanceID == v.InstanceID {
			if planID != "" {
				v.Payload.PlanId = planID
			}
			if params != nil {
				v.Payload.Parameters = params
			}
			serviceInstancePayloadList = append(serviceInstancePayloadList[:k], serviceInstancePayloadList[k+1:]...)
			serviceInstancePayloadList = append(serviceInstancePayloadList, v)
		}
	}
}

func RemoveServiceInstancePayload(serviceID, planID, instanceID string) {
	for k, v := range serviceInstancePayloadList {
		if instanceID == v.InstanceID &&
			(serviceID == v.Payload.ServiceId && planID == v.Payload.PlanId) {
			serviceInstancePayloadList = append(serviceInstancePayloadList[:k], serviceInstancePayloadList[k+1:]...)
		}
	}
}

func StoreServiceBindingPayload(payload *ServiceBindingPayload) {
	serviceBindingPayloadList = append(serviceBindingPayloadList, payload)
}

func FindServiceBindingPayload(instanceID, bindingID string) (*ServiceBindingPayload, error) {
	for _, v := range serviceBindingPayloadList {
		if instanceID == v.InstanceID && bindingID == v.BindingID {
			return v, nil
		}
	}
	return nil, errors.New("cannot find specified service binding!")
}

func RemoveServiceBindingPayload(serviceID, planID, instanceID, bindingID string) {
	for k, v := range serviceBindingPayloadList {
		if (instanceID == v.InstanceID && bindingID == v.BindingID) &&
			(serviceID == v.ServiceID && planID == v.PlanID) {
			serviceBindingPayloadList = append(serviceBindingPayloadList[:k], serviceBindingPayloadList[k+1:]...)
		}
	}
}

func CheckIfServiceIDExists(serviceID string) bool {
	for _, v := range catalogPayload.Services {
		if serviceID == v.Id {
			return true
		}
	}
	return false
}

func CheckIfPlanIDExists(serviceID, planID string) bool {
	for _, v := range catalogPayload.Services {
		if serviceID == v.Id {
			for _, p := range v.Plans {
				if planID == p.Id {
					return true
				}
			}
		}
		continue
	}
	return false
}

func CheckIfServiceInstanceExists(serviceID, planID, instanceID string) bool {
	for _, v := range serviceInstancePayloadList {
		if instanceID == v.InstanceID &&
			(serviceID == v.Payload.ServiceId && planID == v.Payload.PlanId) {
			return true
		}
	}
	return false
}

func CheckIfServiceBindingExists(serviceID, planID, instanceID, bindingID string) bool {
	for _, v := range serviceBindingPayloadList {
		if (instanceID == v.InstanceID && bindingID == v.BindingID) &&
			(serviceID == v.ServiceID && planID == v.PlanID) {
			return true
		}
	}
	return false
}

func CheckIfServiceInstanceExistsWithDifferentProperties(serviceID, planID, instanceID string, params interface{}) bool {
	for _, v := range serviceInstancePayloadList {
		if instanceID == v.InstanceID &&
			(serviceID != v.Payload.ServiceId || planID != v.Payload.PlanId || !reflect.DeepEqual(params, v.Payload.Parameters)) {
			return true
		}
	}
	return false
}

func CheckIfServiceBingdingExistsWithDifferentProperties(serviceID, planID, instanceID, bindingID string, params interface{}) bool {
	for _, v := range serviceBindingPayloadList {
		if (instanceID == v.InstanceID && bindingID == v.BindingID) &&
			(serviceID != v.ServiceID || planID != v.PlanID || !reflect.DeepEqual(params, v.Payload.Parameters)) {
			return true
		}
	}
	return false
}
